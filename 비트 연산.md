# 비트 연산

#### 프로그래밍 언어에서 지원하는 비트 연산자

| 연산자 |                   기능                   |
| :----: | :--------------------------------------: |
|   &    |           비트 단위로 AND 연산           |
|   \|   |           비트 단위로 OR 연산            |
|   ^    | 비트 단위로 XOR 연산 (같으면 0 다르면 1) |
|   ~    |  단한 연산자, 피연산자의 모든 비트 반전  |
|   <<   |    피연산자의 비트 열을 왼쪽으로 이동    |
|   >>   |   피연산자의 비트 열을 오른쪽으로 이동   |

- 일반적으로 다른 연산들에 비해 실행시간이 적음!!
- ==따라서 연산 속도 향상 혹은 메모리 절약 가능==
  - 예시) 짝수 / 홀수 구별
    - N % 2 모듈러 연산자 이용
    - N & 1 마지막 비트 값이 1인지 0인지 보고 판단





#### shift 연산자 

> 1 << n

- 정수를 n 만큼 왼쪽으로 shift 시 2를 곱한 결과를 얻을 수 있음
- 즉 1을 n 만큼 왼쪽으로 shift 하면 2^n^ 값을 가짐
- 2^n^ 은 원소가 n개일 경우 모든 부분 집합의 수
- Power set (모든 부분 집합) 
  - 공집합, 자기 자신을 포함한 모든 부분 집합
  - 즉 각 원소가 포함되거나, 되지않거나 2가지 경우를 갖으므로 2^n^

> i & (1 << j )

- i의 j번 째 비트가 1인지 아닌지 의미

  i 가 `1 0 0 0 1 0 0 0` 이고

  j 가 7일 경우

  1 << j는 `1 0 0 0 0 0 0 0` 

- i & (1 << j ) 계산 시, j번 째 비트가 1 이 아니라면 0 을 리턴하고

  그렇지 않을 경우 0이 아닌 값을 리턴 (공통된 값인 2^7^)

**이 때 j 번째는 뒤에서부터 0번, 1번 … j번 임에 주의**



> BitPrint(i)

- 8 비트의 문자형 변수에 저장된 비트값들을 출력

  

- 해당 코드는 4 바이트 크기의 인트형 변수에 저장된 값들을 한 바이트씩 읽어서 비트 형태로 출력한다.

  ```python
  for i in range(0, 25, 8):
  	BitPrint(x >> i)
  	print(end=" ")
  ```



- 16진수는 0x로 시작하여 숫자 0~9, 문자 A~F 사용하여 표현 

  a = 0x10와 같은 16진수 한자리값 -> 2진수 4개의 비트값으로 저장됨





#### Endianness (엔디안)

> 컴퓨터의 메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법
>
> (하드웨어 아키텍쳐마다 다름 : 따라서 바이트 단위와 워드 단위 변환하여 연산 시, 제대로 이해하지 않으면 오류 발생시킬 가능성)

1. Big-endian : 큰 단위가 앞에 나옴. 네트워크
2. Little-endian : 작은 단위가 앞에 나옴. 대다수 desktop 컴퓨터

|     종류      | 0x1234 표현 | 0x12345678 표현 |
| :-----------: | :---------: | :-------------: |
|  Big-endian   |    12 34    |   12 34 56 78   |
| Little-endian |    34 12    |   78 56 34 12   |



> 내 컴퓨터는 어떤 엔디안?

- 4바이트의 16진수 표현에서 큰 단위의 값 00이 메모리에 시작주소에 해당하는 바이트에 저장된다면 빅 엔디안, 그렇지 않으면 리틀 엔디안

-  n = 0x00111111 의 경우

  ````python
  n = 0x00111111
  if n & 0x11: # 0x11 로 시작하면 작은 단위부터 저장되고 있다는 뜻
  	print("이런 경우 little endian")
  else: # 그렇지 않은 경우는 큰 단위인 00 부터 시작되고 있다는 뜻
  	print("이 경우는 Big endian")
  ````





#### XOR 연산자

- XOR 연산자 (^) 를 사용하여 변환된 값은 한 번 더 XOR 연산자 (^) 사용 시 복구가능

  ````python
  a = 0x86
  key = 0xAA
  
  BitPrint(a) # 10000110
  
  a ^= key
  BitPrint(a) # 00101100
  
  a ^= key
  BitPrint(a) # 10000110
  ````

  